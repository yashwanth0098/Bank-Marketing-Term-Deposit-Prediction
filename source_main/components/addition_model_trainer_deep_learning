import os
import sys
import numpy as np
import tensorflow as tf
from tensorflow.keras import layers, models, callbacks, optimizers

import mlflow
import dagshub

from source_main.exception.exception import Bank_Exception
from source_main.logging.logger import logging
from source_main.entity.config import ModelTrainerConfig
from source_main.entity.artifact import DataTransformationArtifact, ModelTrainerArtifact
from source_main.utils.main_utlis.utils import load_numpy_array_data, save_object
from source_main.utils.ml_utlis.metric.classification_metric import get_classification_metric

dagshub.init(repo_owner="yashwanth0098", repo_name="deposit_classification_dl", mlflow=True)

class DLModelTrainer:
    def __init__(self, model_trainer_config: ModelTrainerConfig, data_transformation_artifact: DataTransformationArtifact):
        try:
            self.model_trainer_config = model_trainer_config
            self.data_transformation_artifact = data_transformation_artifact
        except Exception as e:
            raise Bank_Exception(e, sys)

    def build_model(self, input_dim, output_dim):
        """Define a simple deep neural network."""
        model = models.Sequential([
            layers.Dense(128, activation='relu', input_dim=input_dim),
            layers.Dropout(0.3),
            layers.Dense(64, activation='relu'),
            layers.Dropout(0.2),
            layers.Dense(output_dim, activation='sigmoid' if output_dim == 1 else 'softmax')
        ])
        model.compile(
            optimizer=optimizers.Adam(learning_rate=0.001),
            loss='binary_crossentropy' if output_dim == 1 else 'categorical_crossentropy',
            metrics=['accuracy', tf.keras.metrics.Precision(), tf.keras.metrics.Recall()]
        )
        return model

    def track_mlflow(self, model_name, history, classification_metric):
        """Track training metrics and performance to MLflow."""
        try:
            with mlflow.start_run(run_name=model_name):
                mlflow.log_param("Model", model_name)
                mlflow.log_metric("final_accuracy", classification_metric.accuracy_score)
                mlflow.log_metric("final_precision", classification_metric.precision_score)
                mlflow.log_metric("final_recall", classification_metric.recall_score)
                mlflow.log_metric("final_f1", classification_metric.f1_score)

                # Log learning curve
                for epoch, acc in enumerate(history.history['accuracy']):
                    mlflow.log_metric("train_accuracy", acc, step=epoch)
                for epoch, val_acc in enumerate(history.history['val_accuracy']):
                    mlflow.log_metric("val_accuracy", val_acc, step=epoch)

                mlflow.keras.log_model(model=self.model, artifact_path="model")

        except Exception as e:
            raise Bank_Exception(e, sys)

    def train_model(self, X_train, X_test, y_train, y_test):
        """Train a Deep Learning model."""
        try:
            input_dim = X_train.shape[1]
            output_dim = 1  # for binary classification

            self.model = self.build_model(input_dim, output_dim)
            logging.info(f"Model architecture:\n{self.model.summary()}")

            # Callbacks
            early_stop = callbacks.EarlyStopping(monitor='val_loss', patience=5, restore_best_weights=True)

            # Train
            history = self.model.fit(
                X_train, y_train,
                validation_data=(X_test, y_test),
                epochs=50,
                batch_size=32,
                callbacks=[early_stop],
                verbose=1
            )

            # Evaluate
            y_pred_prob = self.model.predict(X_test)
            y_pred = (y_pred_prob > 0.5).astype(int)

            classification_metric = get_classification_metric(y_true=y_test, y_pred=y_pred)
            logging.info(f"Deep Learning model performance: {classification_metric}")

            # Log to MLflow
            self.track_mlflow("DeepLearning_MLP", history, classification_metric)

            # Save model
            model_path = self.model_trainer_config.trainer_model_file_path
            os.makedirs(os.path.dirname(model_path), exist_ok=True)
            self.model.save(model_path)

            # Create artifact
            model_trainer_artifact = ModelTrainerArtifact(
                trained_model_file_path=model_path,
                training_metric_artifact=None,
                test_metric_artifact=classification_metric
            )
            return model_trainer_artifact

        except Exception as e:
            raise Bank_Exception(e, sys)

    def initiate_model_trainer(self):
        """Load transformed arrays and start training."""
        try:
            train_array = load_numpy_array_data(self.data_transformation_artifact.transformed_train_file_path)
            test_array = load_numpy_array_data(self.data_transformation_artifact.transformed_test_file_path)

            X_train, y_train = train_array[:, :-1], train_array[:, -1]
            X_test, y_test = test_array[:, :-1], test_array[:, -1]

            model_trainer_artifact = self.train_model(X_train, X_test, y_train, y_test)
            return model_trainer_artifact

        except Exception as e:
            raise Bank_Exception(e, sys)
